""" 
DataClass UI
------------

This module allows to generate a simple UI's for dataclasses,
which allows to edit the values of a dataclass.
"""
from functools import partial
import inspect
import re
from dataclasses import MISSING, Field, dataclass, field, fields
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Union
from omc3_gui.utils import file_dialogs

from qtpy import QtWidgets

from omc3_gui.utils.widgets import HorizontalSeparator
from omc3_gui.utils import colors
import logging

LOGGER = logging.getLogger(__name__)




# Helper for the dataclass definitions -----------------------------------------
@dataclass
class MetaData:
    label: Optional[str] = None
    comment: Optional[str] = None
    validate: Optional[Callable] = None

    def __getitem__(self, key):
        return getattr(self, key)

    def get(self, key, default=None):
        return getattr(self, key, default)

    
def metafield(label: str, comment: str, default=MISSING, validate: Optional[Callable] = None) -> Field:
    """ Convenience function to create a dataclass-field with metadata. """
    return field(default=default, metadata=MetaData(label=label, comment=comment, validate=validate))


def choices_validator(*choices: Any) -> Callable:
    """ Return a validator that checks if a given value is in the choices. """
    def validator(value):
        if value not in choices:
            raise ValueError(f"Value {value} is not in {choices}.")
    return validator

class FilePath(Path):
    """ Convenience Class to indicate that the Path should lead to a file. """
    pass


class DirectoryPath(Path):
    """ Convenience Class to indicate that the Path should lead to a directory. """
    pass



# DataClass UI Controller -------------------------------------------------------- 

@dataclass
class FieldUIDef:
    """ Definition of an FieldUI to be generated by 
    :func:`omc3_gui.utils.dataclass_ui.dataclass_ui_builder`.
    This defines how the label and edit-field widgets should look like
    for a field in the dataclass to be UI'ed.
    Missing information is parsed in from the dataclass 
    isetlf if possible, but values given here take precedence. 
    """
    name: str                        # name of the field in the dataclass
    label: Optional[str] = None      # label of the field
    type: Optional[type] = None       # type of the field's data, needs to be instanciable
    comment: Optional[str] = None    # comment for the field, e.g. used for tooltips
    editable: Optional[bool] = True  # sets field to be editable


@dataclass
class FieldUI:
    """ UI-container for a dataclass field, 
    as generated by :meth:`omc3_gui.utils.dataclass_ui.DataClassUI.dataclass_ui_builder`
    and attached to :class:`omc3_gui.utils.dataclass_ui.DataClassUI`.
    """
    widget: QtWidgets.QWidget  # edit-widget to edit field value
    label: QtWidgets.QLabel    # label-widget of the field
    get_value: Callable        # getter for the widget value, returns the value as appropriate type for the dataclass
    set_value: Callable        # setter for the widget value
    text_color: Optional[str] = colors.TEXT_DARK  # default text-color for both widget and label
    modified: bool = False     # flag indicating if the widget-content has been modified by the user

    def __post_init__(self):
        """ Connects the widget to the label and sets the text-color. """
        try:
            self.widget.textChanged.connect(self.has_changed)
        except AttributeError:
            self.widget.valueChanged.connect(self.has_changed)
        self.widget.setStyleSheet(f"color: {self.text_color};")
        self.label.setStyleSheet(f"QLabel {{color: {self.text_color}}};") 

    def has_changed(self):
        """ Triggered when the widget has been modified.
        Sets then the modified flag and changes label font.
         """
        self.modified = True
        font = self.label.font()
        font.setItalic(True)
        self.label.setFont(font)
    
    def reset(self):
        """ Reset the label font to normal and clear the modified flag. """
        self.modified = False
        font = self.label.font()
        font.setItalic(False)
        self.label.setFont(font)


@dataclass
class DataClassUI:
    """ Controller for the UI representation of a dataclass. 
    It contains a grid-layout that can be added to any QWidget/QLayout.   
    """
    layout: QtWidgets.QGridLayout   # final layout of the UI for dataclass
    model: object = None            # dataclass instance
    fields: Dict[str, FieldUI] = field(default_factory=dict) # stored field UI-elements

    def reset_labels(self):
        """ Resets all labels to indicate that the field shows the currently set value in the dataclass."""
        for name in self.fields.keys():
            self.fields[name].reset()
    
    def update_widget_from_model(self, name: str):
        """ Updates the edit-widget of the given field from the dataclass values. 
        
        Args:
            name (str): name of the field in the dataclass
        """
        value = getattr(self.model, name)
        if value is not None:
            self.fields[name].set_value(value)
    
    def update_model_from_widget(self, name: str):
        """ Updates the dataclass value of the given field from the edit-widget. 
        
        Args:
            name (str): name of the field in the dataclass
        """
        field: FieldUI = self.fields[name]

        if not field.modified:  # avoid replacing 'None' with widget defaults
            LOGGER.debug(f"Field {name} was not modified.")
            return 

        value = field.get_value()
        setattr(self.model, name, value)

    def update_ui(self):
        """ Updates all edit-widgets from the dataclass values. """
        for name in self.fields.keys():
            self.update_widget_from_model(name)

    def update_model(self):
        """ Updates all dataclass fields from the current edit-widget values. """
        for name in self.fields.keys():
            self.update_model_from_widget(name)

    def validate(self, only_modified: bool = False):
        """ Checks all edit-widgets for valid choices. """
        invalid_fields_str = []
        for name in self.fields.keys():
            field = self.model.__dataclass_fields__[name]
            field_ui = self.fields[field.name]
            if only_modified and not field_ui.modified:
                continue
            
            validate_function = field.metadata.get("validate")
            if validate_function is not None:
                value = self.fields[field.name].get_value()
                if not validate_function(value):
                    invalid_fields_str.append(f"{field_ui.label.text()}: {value} is not a valid choice.")

        if invalid_fields_str:
            full_str = "\n".join(invalid_fields_str)
            raise ValueError(f'The following fields contain wrong values:\n{full_str}')

    @classmethod
    def build_dataclass_ui(cls, 
        field_def: Sequence[Union[FieldUIDef, str]], dclass: Union[type, object] = None) -> 'DataClassUI':
        """ Builds a DataClassUI from a list of field definitions.
        NOTE: `dclass` is not automatically attached to the resulting class,
        as this function works with classes and instances, but the attached object needs to be the instance.
        
        Args:
            field_def (Sequence[Union[FieldUIDef, str]]): list of field definitions
            dclass (Union[type, object], optional): dataclass type or instance. Defaults to None. 

        Returns:
            DataClassUI: A grid-layout containing edit-widgets and labels.
        """
        field_instances = {}
        if dclass is not None:
            field_instances = {field.name: field for field in fields(dclass)}

        layout = QtWidgets.QGridLayout()
        dataclass_ui = cls(layout)

        for idx_row, field in enumerate(field_def):
            if field is None:
                layout.addWidget(HorizontalSeparator(), idx_row, 0, 1, 3)
                continue

            if isinstance(field, str):
                layout.addWidget(QtWidgets.QLabel(field), idx_row, 0)
                continue
            
            if field.name not in field_instances:
                raise ValueError(f"Field {field.name} not found in dataclass {dclass}")
            field_inst = field_instances[field.name]
            
            # Label ---
            qlabel = QtWidgets.QLabel(field.label or field_inst.metadata.get("label", field.name))
            qlabel.setToolTip(field.comment or field_inst.metadata.get("comment", ""))
            layout.addWidget(qlabel, idx_row, 0)
            
            # User input ---
            # If field.type is not given, use evaluate from dataclass. 
            # Check __args__ in case of Union/Optional and use first one.
            # The type needs to be instanciable!
            field_type = field.type or getattr(field_inst.type, "__args__", [field_inst.type])[0]  

            widget = TYPE_TO_WIDGET_MAP.get(field_type, QtWidgets.QLineEdit)()

            try:
                widget.setReadOnly(not field.editable)
            except AttributeError:
                widget.setEnabled(field.editable)


            get_value, set_value = build_getter_setter(widget, field_type)
            dataclass_ui.fields[field.name] = FieldUI(
                widget=widget, 
                label=qlabel,
                set_value=set_value,
                get_value=get_value,
                text_color=colors.TEXT_DARK if field.editable else colors.GREYED_OUT_TEXT_DARK
            )
            
            if not issubclass(field_type, Path) or not field.editable:
                layout.addWidget(widget, idx_row, 1, 1, 2)
            else:
                layout.addWidget(widget, idx_row, 1)
                # Add Path selection button ---
                button = QtWidgets.QPushButton("...")
                button.setFixedWidth(30)
                
                if field_type is FilePath:
                    dialog = file_dialogs.OpenFileDialog

                elif field_type is DirectoryPath:
                    dialog = file_dialogs.OpenDirectoryDialog 

                else:
                    dialog = file_dialogs.OpenAnySingleDialog

                button.clicked.connect(partial(
                    run_dialog, 
                    dialog=dialog,
                    get_value=get_value,
                    set_value=set_value))
                layout.addWidget(button, idx_row, 2)

        return dataclass_ui


# View -------------------------------------------------------------------------

class DataClassDialog(QtWidgets.QDialog):

    WINDOW_TITLE = "Edit DataClass"
    DEFAULT_SIZE = (800, 600)  # width, height, use -1 for auto
    
    def __init__(self, dataclass_ui: DataClassUI, parent=None):
        super().__init__(parent)
        self._button_ok: QtWidgets.QPushButton = None
        self._button_cancel: QtWidgets.QPushButton = None
        self._button_box: QtWidgets.QDialogButtonBox = None

        self._dataclass_ui: DataClassUI = dataclass_ui
        self._build_gui()
        self._connect_signals()
        self._set_size(width=self.DEFAULT_SIZE[0], height=self.DEFAULT_SIZE[1])
        self.update_ui()


    def _set_size(self, width: int = -1, height: int = -1):
        # Set position to the center of the parent (does not work in WSL for me, jdilly 2023)
        # parent = self.parent()
        # if parent is not None:
        #     parent_geo = parent.geometry()
        #     parent_pos = parent.mapToGlobal(parent.pos())  # multiscreen support
        #     if width >= 0:
        #         x = parent_pos.x() + parent_geo.width() / 2
        #     else:
        #         x = parent_pos.x() + (parent_geo.width() - width) / 2

        #     if height >=0 :
        #         y = parent_pos.y() + parent_geo.height() / 2
        #     else:
        #         y = parent_pos.y() + (parent_geo.height() - height) / 2
        #     self.move(x, y)
        
        # Set size
        self.resize(width, height)

    def _build_gui(self):
        self.setWindowTitle(self.WINDOW_TITLE)
        layout = QtWidgets.QVBoxLayout()
        layout.addLayout(self._dataclass_ui.layout)

        QBtn = QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel
        self._button_box = QtWidgets.QDialogButtonBox(QBtn)
        layout.addWidget(self._button_box)

        self.setLayout(layout)
    
    def _connect_signals(self):
        self._button_box.accepted.connect(self.accept)
        self._button_box.rejected.connect(self.reject)

    def update_ui(self, new_model: object = None):
        if new_model is not None:
            self._dataclass_ui.model = new_model 
        self._dataclass_ui.update_ui()  # triggers changes, so the labels appear in "changed" state
        self._dataclass_ui.reset_labels()  # so we reset them

    def accept(self):
        try:
            self._dataclass_ui.validate(only_modified=True)
        except ValueError as e:
            QtWidgets.QMessageBox.critical(self, "Error", str(e))
            return

        self._dataclass_ui.update_model()
        super().accept() 


# Type-to-Widget Helpers ----------------------------------------------------------------

class QFullIntSpinBox(QtWidgets.QSpinBox):
    """ Like a QSpinBox, but overwriting default range(0,100) with maximum integer range. """

    def __init__(self, parent: Optional[QtWidgets.QWidget] = None) -> None:
        super().__init__(parent)
        self.setRange(-2**31, 2**31 - 1)  # range of signed 32-bit integers 


TYPE_TO_WIDGET_MAP = {
    int: QFullIntSpinBox,  # Maybe just use QLineEdit as well?
    float: QtWidgets.QLineEdit,
    str: QtWidgets.QLineEdit,
    Path: QtWidgets.QLineEdit,
    bool: QtWidgets.QCheckBox,
}


def build_getter_setter(widget: QtWidgets.QWidget, field_type: type) -> Tuple[Callable, Callable]:
    """ Getter/Setter Factory for widgets. 
    
    Args:
        widget (QtWidgets.QWidget): The widget to get/set the value of.
        field_type (type): The type of the dataclass field.
    """
    if isinstance(widget, QtWidgets.QCheckBox):
        def get_value() -> bool:
            return widget.isChecked()

        def set_value(value: bool):
            widget.setChecked(value)
    
    if isinstance(widget, QtWidgets.QSpinBox):
        def get_value():
            return field_type(widget.value())

        def set_value(value):
            widget.setValue(value)
        
    else:   # Any kind of widget should be able to handle strings.      
        def get_value():
            return field_type(widget.text())

        def set_value(value):
            widget.setText(str(value))
    return get_value, set_value        


def run_dialog(dialog: file_dialogs.OpenFilesDialog, get_value: Callable, set_value: Callable):
    """ Asks the user to select a directory/file, using the `get_value` function 
    o determine the default directory and passing the result to `set_value` if not `None`.

    Args:
        dialog (file_dialogs.OpenFilesDialog): The dialog to run.
        get_value (Callable): The function to get the last value, e.g. from a widget.
        set_value (Callable): The function to set the value returned from the dialog.
    """
    path = dialog(directory=get_value().parent).run_selection_dialog()
    if path is not None:
        set_value(path)


# Other ------------------------------------------------------------------------

def get_field_inline_comments(dclass: type) -> Dict[str, str]:
    """
    Returns a dictionary mapping field names to their associated inline code-comments.
    Has been replaced by the use of the metadata, but I like the function,
    so I leave it here. (jdilly 2023)

    Parameters:
        dclass (type): The data class to extract field comments from.

    Returns:
        Dict[str, str]: A dictionary mapping field names to their associated comments.
    """
    matcher = re.compile(r"^(?P<field>[a-zA-Z_]+)\s*:\s*[^#]+#\s*(?P<comment>.*)\s*$")
    source = inspect.getsource(dclass)

    found_fields = {}
    for line in source.splitlines()[2:]:  # first two is @dataclass and name
        line = line.strip()
        if line.startswith('def '):
            break

        match = matcher.match(line)
        if match:
            found_fields[match.group('field')] = match.group('comment')

    return found_fields
